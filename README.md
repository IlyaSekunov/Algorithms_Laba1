# Лабораторная работа по алгоритмам и структурам данных №1

<h2>Задача</h2> 
Тест трех алгоритмов по поиску элемента в прямоугольной таблице размером M x N, отсортированной одновременно по столбцам и строкам (A[i][j] <= A[m][n] -> i <= m, j <= n). Искомый элемент будем называть target. N по условию задачи фиксировано и равно N = 2^13, M <= N и равное M = 2^x, где x = 0, 1, 2 ... 13. Тестируются слудующий алгоритмы:

<h2>Бинарный поиск по строкам (1)</h2>
Идея проста: итерируемся по каждой строке таблицы и запускаем бинарный поиск по данной строке. В случае если targer найден, возвращаем пару [i, j], гле i - текущая строка, j - текущий столбец.
</br>
Сложность - O(M * logN). 

<h2>"Ступенчатый алгоритм" (2)</h2> 
Идея алгорита: начинаем идти с правого верхнего элемента и проверяем, если A[i][j] < target, то спускаемся на строку вниз, если A[i][j] > target, то двигаемся влево на стобец, иначе возвращаем пару [i, j]. Повторяем эту процедуру, пока текущий столбец >= 0 и при этом текущая строка < M. Если не вышли из цикла, то возращаем пару [-1, -1].
</br> 
Сложность - O(N + M).

<h2>Ступенчатый алгоритм с использованием экспоненциального поиска (3)</h2> 
Идея точно такая же как и в ступенчатом алгоритме, только теперь когда текующий рассматриваемый элемент меньше target, то мы ищем насколько нам нужно сместиться по столбцам налево, используя экспоненциальный поиск.
</br>
 Сложность наихудшая - O(M + N), средняя - O(M * log(N/M)).

<h2>Структура проекта и тестирования</h2>
<h3>Генерации таблиц</h3>
В тестировании будут использоваться две генерации данных таблиц для тестирования наихудших случаев каждого из алгоритмов:

1) A[i][j] = (N / M * i + j) * 2, target = 2 * N + 1. Смысл этой генерации в том, что индекс искомого элемента будет находиться на побочной диагонали матрицы.
2) A[i][j] = (N / M * i * j) * 2, target = 16 * N + 1.

<h3>Структура проекта</h3>

<h3>Запуск</h3>
Для запуска программы потребуется сборщик проектов Maven и JDK 21. Если все переменные среды MAVEN_HOME и JAVA_HOME установлены корректно, то запуск приложения осуществляется вызовом команды <b><i>mvn clean javafx:run</i></b> в корневой папке проекта.

<h3>Структура</h3> 

Программа состоит из 4 java файлов:
1) Algorigm.java описывает функциональный интерфейс для алгоритма, который возвращает пару целых чисел, описывающий координаты найденного элемента;
2) TableGenerator.java описывает функциональный интерфейс для функции-генератора таблиц.
3) TableGeneration.java описывает вспомогательный класс, который содержит саму таблицу и target элемент для нее.
4) MainTest.java описывает основной файл для запуска программы.

<h3>Тестирование</h3>
Программа тестирует 3 алгоритма, запоминая результаты каждого алгоритма и в конце рисует графики каждого из алгоритмов, использую средства JavaFX. Для того, чтобы результаты алооритмов были более точные и менее зависимы от распределения процессорных мощностей, на каждой генерации таблиц каждый алгоритм тестируется несколько раз (описывается статической переменной TESTS_COUNT), затем вычисляется среднее арифметическое результатов, которое потом будет использоваться для отображения графика.

График состоит из двух осей: ось абсцисс отображает количество строк в таблице (M), ось ординат отображает время в наносекундах, затраченное алгоритмом.

<h2>Результаты</h2>
</br>
<image src="charts/first_table_generation_test.png">
<i>Результаты при генерации таблицы первым способом</i>
</br>
</br>
</br>
<image src="charts/second_table_generation_test.png">
<i>Результаты при генерации таблицы вторым способом</i>
</br>
</br>

<h2>Выводы</h2> 

Как можем видеть из графиков в целом сложность алгоритмов в теории оправдалась и на практике. (1) алгоритм показавыает наихудщую сложность по ассимптотике и, соответственно, показывает наихудшие результаты на больших объемах данных. Алгоритмы (2) и (3) на данных генерациях таблиц и подборе искомого элемента по ассимптотике очень похожи, поэтому разница между алгоритмами почти невидна. 

Ступенчатый алгоритм с экспоненциальным поиском на первой генерации таблиц при M < N будет показывать ассимптотику - O(M + logN), при достаточно маленьком M. Когда матрица прямоугольная, то алгоритму нужно спуститься в левый нижний угол и при такой генерации это будет происходить преимущественно быстрее засчет экспоненциального поиска. Когда M будет приближаться к N, то разница между обычным ступенчатым поиском и с экспоненциальным поиском будет все менее заметна, экспоненциальный поиск будет даже в проигрыше из-за накладных ресурсов вызова бинарного поиска. Это объясняется тем, что алгоритму нужно дойти до левого нижнего угла таблицы, при этом когда будет запускаться экспоненциальный поиск для поиска смещения влево, этот поиск будет завершаться почти сразу же, сделав 1 - 2 операции, что можно приравнять к обычному смещению влево на 1 столбец. Следовательно данный алгоритм будет на такой генерации почти идентичным обычному ступенчатому алгоритму.

На второй генерации получается так, что алгоритмам приходится больше раз ходить влево относительно первой генерации, поэтому мы видим, что экспоненциальный поиск выигрывает небольшое количество времени при возрастании количества данных, при маленькой же таблице разница почти незаметна.

Несмотря на результаты, важно учитывать определенный процент погрешности, возникающий из-за различного распределения процессорного времени, запуска посторонних задач и т.п. Запуск программы на любом другом ПК может показать немного другие результаты, но в целом ассимптотичсеки при увеличении данных результаты и графики должны выглядеть приблизительно одинаково.